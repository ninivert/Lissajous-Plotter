{"version":3,"sources":["../../src/scripts/index.js"],"names":["SPACING","RADIUS","NODERADIUS","COUNT","BASESPEED","canvas","document","getElementById","ctx","getContext","alpha","NEXTFRAME","CIRCLES","init","window","WIDTH","HEIGHT","UNIT","CLRX","CLRY","CLRH","CLRW","width","height","cancelAnimationFrame","requestAnimationFrame","draw","Array","fill","map","x","i","rgb","hslToRgb","Math","floor","y","speed","angle","color","toString","join","projx","cos","projy","sin","h","s","l","r","g","b","hue2rgb","p","q","t"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * IDEAS\r\n * Use Canvas Path2D() to store the curves\r\n * but that would mean creating many instances,\r\n * clearing, redrawing in every frame\r\n * which we can't really afford\r\n */\r\n\r\n// Layout stuffs\r\nconst SPACING = 25\r\nconst RADIUS = 50\r\nconst NODERADIUS = 4\r\n// Circle stuffs \r\nconst COUNT = 4\r\nconst BASESPEED = 0.02\r\n// const RELSPEED = 1.5\r\n// Canvasw\r\nconst canvas = document.getElementById('canvas')\r\nconst ctx = canvas.getContext('2d', { alpha: false })\r\n\r\nlet NEXTFRAME\r\nlet CIRCLES\r\n\r\nfunction init() {\r\n\t// A few constants derived from other constants\r\n\twindow.WIDTH = 2*RADIUS*(COUNT+1) + (COUNT+2)*SPACING\r\n\twindow.HEIGHT = 2*RADIUS*(COUNT+1) + (COUNT+2)*SPACING\r\n\t// One unit is the place that a circle + spacing around takes\r\n\twindow.UNIT = SPACING + 2*RADIUS\r\n\t// Canvas clearing values that don't need to be constantly reevaluated\r\n\twindow.CLRX = SPACING + 2*RADIUS\r\n\twindow.CLRY = 0.5*SPACING\r\n\twindow.CLRH = SPACING + 2*RADIUS\r\n\twindow.CLRW = WIDTH - CLRX\r\n\r\n\tcanvas.width = WIDTH\r\n\tcanvas.height = HEIGHT\r\n\r\n\tcancelAnimationFrame(NEXTFRAME)\r\n\tNEXTFRAME = requestAnimationFrame(draw)\r\n\r\n\tCIRCLES = new Array(COUNT).fill().map((x, i) => {\r\n\t\tlet rgb = hslToRgb((i+1)/COUNT, 1, 0.8)\r\n\t\trgb = rgb.map(x => Math.floor(x))\r\n\r\n\t\treturn {\r\n\t\t\tx: SPACING*(i+2) + RADIUS*(2*i+3),\r\n\t\t\ty: SPACING + RADIUS,\r\n\t\t\tspeed: BASESPEED*(i+1),\r\n\t\t\tangle: 0,\r\n\t\t\tcolor: '#' + rgb.map(x => x.toString(16)).join(''),\r\n\t\t\trgb: rgb,\r\n\t\t\t// Storing the sin and cos because these operations are expensive\r\n\t\t\tprojx: RADIUS*Math.cos(0),\r\n\t\t\tprojy: RADIUS*Math.sin(0)\r\n\t\t}\r\n\t})\r\n}\r\n\r\n\r\ninit()\r\n\r\n\r\n/**\r\n * https://gist.github.com/mjackson/5311256\r\n * Converts an HSL color value to RGB. Conversion formula\r\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\r\n * Assumes h, s, and l are contained in the set [0, 1] and\r\n * returns r, g, and b in the set [0, 255].\r\n *\r\n * @param   Number  h       The hue\r\n * @param   Number  s       The saturation\r\n * @param   Number  l       The lightness\r\n * @return  Array           The RGB representation\r\n */\r\nfunction hslToRgb(h, s, l) {\r\n  var r, g, b;\r\n\r\n  if (s == 0) {\r\n    r = g = b = l; // achromatic\r\n  } else {\r\n    function hue2rgb(p, q, t) {\r\n      if (t < 0) t += 1;\r\n      if (t > 1) t -= 1;\r\n      if (t < 1/6) return p + (q - p) * 6 * t;\r\n      if (t < 1/2) return q;\r\n      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\r\n      return p;\r\n    }\r\n\r\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n    var p = 2 * l - q;\r\n\r\n    r = hue2rgb(p, q, h + 1/3);\r\n    g = hue2rgb(p, q, h);\r\n    b = hue2rgb(p, q, h - 1/3);\r\n  }\r\n\r\n  return [ r * 255, g * 255, b * 255 ];\r\n}"]}